<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F03%2F31%2Fwebpack%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425// 简单配置const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', // 输入：项目主文件（入口文件） output: &#123; // 输出 path: path.resolve(__dirname, 'dist'), //想要生成(emit)到哪里 filename: 'my-first-webpack.bundle.js' // webpack bundle 的名称 &#125;, module: &#123; // 配置加载资源 rules: [ // 规则 &#123; test: /\.txt$/, use: 'raw-loader' &#125; // webpack 编译器碰到「在 require()/import 语句中被解析为 '.txt' 的路径」时，在对它打包之前，先使用 raw-loader 转换一下。 // test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 // use 属性，表示进行转换时，应该使用哪个 loader。 ], plugins: [ // webpack插件配置 // new webpack.optimize.UglifyJsPlugin(), // 现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ] &#125;&#125;;module.exports = config; 入口(entry)可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。 单个入口（简写）语法用法：entry: string|Array&lt;string&gt; 123456const config = &#123; entry: './path/to/my/entry/file.js' // 简写 // entry: &#123; // main: './path/to/my/entry/file.js' // &#125;&#125;; 对象语法用法：entry: {[entryChunkName: string]: string|Array&lt;string&gt;} 12345678const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;;module.exports = config; 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 123456789const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config;// 此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。 如果配置创建了多个单独的 “chunk”，则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。在你的应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览： 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125; 内联：在每个 import 语句中显式指定 loader。 可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 1import Styles from 'style-loader!css-loader?modules!./styles.css'; 通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{“key”:”value”,”foo”:”bar”}。 CLI：在 shell 命令中指定它们。 你也可以通过 CLI 使用 loader： 1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。 插件(plugins)想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。webpack.config.js 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ // new webpack.optimize.UglifyJsPlugin(), // 现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 配置Configuration mode/–mode参数4.X 新增了mode/–mode参数来表示是开发还是生产，mode有两个可选值：development和production，production不支持监听，production侧重于打包后的文件大小，development侧重于构建的速度。webpack --mode development 也可以在配置文件中配置： 12345// webpack.config.jsmodule.exports = &#123; mode: "production", // ...&#125; HtmlWebpackPluginHtmlWebpackPlugin 会默认生成 index.html 文件首先安装插件，并且调整 webpack.config.js 文件：npm install --save-dev html-webpack-plugin 123456789+ const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123;+ plugins: [+ new HtmlWebpackPlugin(&#123;+ title: 'Output Management'+ &#125;)+ ] &#125;; 清理 /dist 文件夹clean-webpack-plugin 是一个比较普及的管理插件，让我们安装和配置下。npm install clean-webpack-plugin --save-dev 12345678910+ const CleanWebpackPlugin = require('clean-webpack-plugin'); module.exports = &#123; plugins: [+ new CleanWebpackPlugin(['dist']), // 在每次构建前清理 /dist 文件夹 new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;) ], &#125;; source map为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。source map 有很多不同的选项可用，请务必仔细阅读它们，以便可以根据需要进行配置。 123module.exports = &#123; devtool: 'inline-source-map', &#125;; webpack-dev-serverwebpack-dev-server 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。让我们设置以下：npm install --save-dev webpack-dev-server修改配置文件，告诉开发服务器(dev server)，在哪里查找文件： 123456 module.exports = &#123;+ devServer: &#123;+ port: 8000,+ contentBase: './dist'+ &#125; &#125;; 以上配置告知 webpack-dev-server，在 localhost:8000(默认8080) 下建立服务，将 dist 目录下的文件，作为可访问文件。 让我们添加一个 script 脚本，可以直接运行开发服务器(dev server)： 123"scripts": &#123;+ "start": "webpack-dev-server --open",&#125;, webpack-dev-server 带有许多可配置的选项。转到相关文档以了解更多。 模块热替换(Hot Module Replacement)模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。 启用此功能实际上相当简单。而我们要做的，就是更新 webpack-dev-server 的配置，和使用 webpack 内置的 HMR 插件 123456789101112131415161718+ const webpack = require('webpack'); module.exports = &#123; devServer: &#123; contentBase: './dist', port: 8000, overlay: &#123; // webpack编译出现错误，则显示到网页上 errors: true, &#125;,+ hot: true // 不刷新热加载数据 &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'Hot Module Replacement' &#125;),+ new webpack.NamedModulesPlugin(),+ new webpack.HotModuleReplacementPlugin() ] &#125;; 注意，我们还添加了 NamedModulesPlugin，以便更容易查看要修补(patch)的依赖 生产环境构建开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。虽然，以上我们将生产环境和开发环境做了略微区分，但是，请注意，我们还是会遵循不重复原则(Don’t repeat yourself - DRY)，保留一个“通用”配置。为了将这些配置合并在一起，我们将使用一个名为 webpack-merge 的工具。通过“通用”配置，我们不必在环境特定(environment-specific)的配置中重复代码。 我们先从安装 webpack-merge 开始，并将之前指南中已经成型的那些代码再次进行分离：npm install --save-dev webpack-merge 123456789101112// project webpack-demo |- package.json- |- webpack.config.js+ |- webpack.common.js+ |- webpack.dev.js+ |- webpack.prod.js |- /dist |- /src |- index.js |- math.js |- /node_modules 1234567891011121314151617181920// webpack.common.js+ const path = require('path');+ const CleanWebpackPlugin = require('clean-webpack-plugin');+ const HtmlWebpackPlugin = require('html-webpack-plugin');++ module.exports = &#123;+ entry: &#123;+ app: './src/index.js'+ &#125;,+ plugins: [+ new CleanWebpackPlugin(['dist']),+ new HtmlWebpackPlugin(&#123;+ title: 'Production'+ &#125;)+ ],+ output: &#123;+ filename: '[name].bundle.js',+ path: path.resolve(__dirname, 'dist')+ &#125;+ &#125;; 12345678910//webpack.dev.js+ const merge = require('webpack-merge');+ const common = require('./webpack.common.js');++ module.exports = merge(common, &#123;+ devtool: 'inline-source-map',+ devServer: &#123;+ contentBase: './dist'+ &#125;+ &#125;); 12345678910// webpack.prod.js+ const merge = require('webpack-merge');// + const UglifyJSPlugin = require('uglifyjs-webpack-plugin'); // 4.X 现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true+ const common = require('./webpack.common.js');++ module.exports = merge(common, &#123;+ plugins: [// + new UglifyJSPlugin() // 4.X 现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true+ ]+ &#125;); 现在，在 webpack.common.js 中，我们设置了 entry 和 output 配置，并且在其中引入这两个环境公用的全部插件。在 webpack.dev.js 中，我们为此环境添加了推荐的 devtool（强大的 source map）和简单的 devServer 配置。最后，在 webpack.prod.js 中，我们引入了之前在 tree shaking 指南中介绍过的 UglifyJSPlugin。4.X 现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true.从webpack 4开始，这也可以通过”mode”配置选项轻松切换，设置为”production”。 123module.exports = &#123;+ mode: "production"&#125;; 现在，我们把 scripts 重新指向到新配置。我们将 npm start 定义为开发环境脚本，并在其中使用 webpack-dev-server，将 npm run build 定义为生产环境脚本： 123456789// package.json &#123; "scripts": &#123;- "start": "webpack-dev-server --open",+ "start": "webpack-dev-server --open --config webpack.dev.js",- "build": "webpack"+ "build": "webpack --config webpack.prod.js" &#125; &#125; 指定环境许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。例如，当不处于生产环境中时，某些 library 为了使调试变得容易，可能会添加额外的日志记录(log)和测试(test)。其实，当使用 process.env.NODE_ENV === ‘production’ 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。我们可以使用 webpack 内置的 DefinePlugin 为所有的依赖定义这个变量： 1234567// webpack.prod.js module.exports = merge(common, &#123;+ new webpack.DefinePlugin(&#123;+ 'process.env.NODE_ENV': JSON.stringify('production')+ &#125;) ] &#125;) 技术上讲，NODE_ENV 是一个由 Node.js 暴露给执行脚本的系统环境变量。通常用于决定在开发环境与生产环境(dev-vs-prod)下，服务器工具、构建脚本和客户端 library 的行为。然而，与预期不同的是，无法在构建脚本 webpack.config.js 中，将 process.env.NODE_ENV 设置为 “production”，请查看 #2537。因此，例如 process.env.NODE_ENV === ‘production’ ? ‘[name].[hash].bundle.js’ : ‘[name].bundle.js’ 这样的条件语句，在 webpack 配置文件中，无法按照预期运行。 ExtractTextWebpackPlugin4.X 版本支持插件 mini-css-extract-plugin安装：npm install --save-dev extract-text-webpack-plugin用法： 123456789101112131415161718const ExtractTextPlugin = require("extract-text-webpack-plugin");module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader" &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin("styles.css"), ]&#125; 它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。 代码分离有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。 防止重复(prevent duplication)webpack 4删除了CommonsChunkPlugin,以支持两个新选项（optimization.splitChunks和optimization.runtimeChunk）。默认配置只会对异步请求的模块进行提取拆分，如果要对entry进行拆分，需要设置optimization.splitChunks.chunks = &#39;all&#39;。optimization.runtimeChunk，设置为true就会自动拆分runtime文件 1234567891011121314151617181920// 默认配置splitChunks: &#123;chunks: "async", // 可选"initial"，"async"和"all" minSize: 30000, // 最小尺寸，默认0, minChunks: 1, // 最小 chunk ，默认1 maxAsyncRequests: 5, // 最大异步请求数，默认5 maxInitialRequests: 3, // 最大初始化请求数，默认3 name: true, cacheGroups: &#123; default: &#123; minChunks: 2, priority: -20 reuseExistingChunk: true, &#125;, vendors: &#123; test: /[\\/]node_modules[\\/]/, // 正则规则验证，如果符合就提取 chunk priority: -10 // 缓存组优先级 &#125; &#125;&#125; CommonsChunkPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。 1234567 module.exports = &#123; plugins: [+ new webpack.optimize.CommonsChunkPlugin(&#123;+ name: 'common' // 指定公共 bundle 的名称。+ &#125;) ] &#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vs code 快捷键]]></title>
    <url>%2F2018%2F03%2F28%2Fvs-code-%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[注释： a) 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/ b) 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u) c) 多行注释：[alt+shift+A] d) 多行注释：/** 移动行：alt+up/down 显示/隐藏左侧目录栏 ctrl + b 复制当前行：shift + alt +up/down 删除当前行：shift + ctrl + k 控制台终端显示与隐藏：ctrl + ~ 查找文件/安装vs code 插件地址：ctrl + p 代码格式化：shift + alt +f 新建一个窗口 : ctrl + shift + n 行增加缩进: ctrl + [ 行减少缩进: ctrl + ] 裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x 字体放大/缩小: ctrl + ( + 或 - ) 拆分编辑器 : ctrl + 1/2/3 切换窗口 : ctrl + shift + left/right 关闭编辑器窗口 : ctrl + w 关闭所有窗口 : ctrl + k + w 切换全屏 : F11 自动换行 : alt + z 显示git : ctrl + shift + g 全局查找文件：ctrl + shift + f 显示相关插件的命令(如：git log)：ctrl + shift + p 选中文字：shift + left / right / up / down 折叠代码： ctrl + k + 0-9 (0是完全折叠) 展开代码： ctrl + k + j (完全展开代码) 删除行 ： ctrl + shift + k 快速切换主题：ctrl + k / ctrl + t 快速回到顶部 ： ctrl + home 快速回到底部 : ctrl + end 格式化选定代码 ：ctrl + k / ctrl +f]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2018%2F03%2F02%2FHTTP%2F</url>
    <content type="text"><![CDATA[TCP/IP通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层分别为四层：应用层、传输层、网络层和数据链路层。 应用层决定了向用户提供应用服务时通信的活动。HTTP 协议处于该层。 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 网络层用来处理在网路上流动的数据包。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 数据链路层用来处理连接网络的硬件部分。利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。 IP 协议按层次分，IP（Internet Protocol）网际协议位于网络层。IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。 TCP 协议按层次分，TCP 位于传输层，提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。 DNS 服务DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 www.hackr.jp。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。 各种协议与 HTTP 协议的关系 URI 和 URL与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。比如 http://hackr.jp/ 就是 URL。Uniform规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易。Resource资源的定义是“可标识的任何东西”。不仅是文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。Identifier表示可标识的对象。也称为标识符。URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。URL 是 URI 的子集。URI 由两个主要的子集构成： URL：通过描述资源的位置来描述资源 URN：通过名字来识别资源，和位置无关 URI 格式表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如/image/logo.gif。绝对 URI 的格式：使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。相对 URL相对 URL 是 URL 一部分，从路径开始，前面木人使用当前文档的设置 123./image/logo.png../script/a.js/css/main.css 登录信息（认证）指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。服务器地址使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似hackr.jp这种 DNS 可解析的名称，或是192.168.1.1这类 IPv4 地址 名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的 IPv6 地址名。服务器端口号指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。查询字符串针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。片段标识符使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。 HTTPHTTP 用于客户端和服务器之间的通信。两台计算机之间使用 HTTP 协议通信时，在一条线路上必定有一端是客户端，另一端是服务器端。HTTP 协议规定，请求从客户端出发，最后服务器端响应该请求并返回。 报文请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。 123456789// 请求行//方法 URI 协议版本GET /form/entry HTTP/1.1// 请求首部字段Host: www.baidu.comConnection: keep-aliveCache-Control: max-age=0// 内容实体name=ueno&amp;age=37 响应报文由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 1234567891011// 状态行//协议版本 状态码 状态码的原因短语HTTP/1.1 200 OK// 响应首部字段Date: Thu, 08 Mar 2018 07:33:56 GMTConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8// 主体&lt;html&gt;··· 当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。 12345// URI为完整的请求URIGET http://baidu.com/index.htm HTTP/1.1// 在首部字段Host中写明网络域名或IP地址GET /index.htm HTTP/1.1Host: baidu.com 如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求 URI 1OPTIONS * HTTP/1.1 首部字段通用首部：客户端和服务器都可以实用的就是通用首部 首部 描述 Connection 客户端和服务器是否保持连接 Date 日期，报文创建时间 Update 给出了发送端可能想要升级使用新版本或协议 Via 显示了报文经过的中间节点（代理、网关） Trailer 如果报文采用分块传输编码方式，可以利用这个首部列出位于报文 trailer 部分的首部集合 Trailer-Encoding 告诉接收端对报文采用什么编码格式 Cache-Control 随报文传送缓存指示 Pragma 早期的随报文传送指示方式 请求首部 首部 描述 Client-IP 客户端 IP From 客户端邮件地址 Host 接收请求的服务器的主机名和端口号 Referer 提供了包含当前请求 URI 的文档的 URL，告诉服务器自己来源 User—Agent 发起请求的客户端应用程序 Accept 告诉服务器能够发送那些媒体类型 Accept-Charset 告诉服务器能够发送那些字符集 Accept-Encoding 告诉服务器能够发送那些编码 Accept-Language 告诉服务器能够发送那些语言 Expect 允许客户端列出请求所要求的服务器行为 If-Match 如果 ETag 和文档当前 ETag 匹配，就获取文档 If-Modified-Since 除非在某个指定日期之后修改过，否则限制这个请求 If-None-Match 如果 ETag 和当前文档 ETag 不符合，获取资源 If-Range 允许对文档否个范围内的条件请求 If-Unmodified-Since 在某个指定日期之后没有修改过，否则现在请求 Cookie 客户端字符串 响应首部 首部 描述 Age 响应持续时间 Server 服务器应用软件名称和版本 Allow 列出了可用的请求方法 Location 告诉客户端实在在哪里，用于定向 Content-Base 解析主体中相对 URL 的基础 URL Content-Encoding 主体编码格式 Content-Language 解析主体时适用的语言 Content-Length 主体的长度或尺寸 Content-Location 资源实际位置 Content-MD5 主体的 MD5 校验和 Content-Range 在整个资源中此实体部分的字节范围 Content-Type 主体的 MIME ETag 主体的实体标记 Expires 过期时间 Last-Modified 实体最后一次修改时间 方法 GET：获取资源GET 是最常用的方法，通常用于请求服务器发送某个资源。指定的资源经服务器端解析后返回响应内容。 POST：传输实体主体POST 用于想服务器发送数据，通常用来支持 HTML 的表单（input、select、textarea），表单中的数据会被发送到服务器 PUT：传输文件和 GET 从服务器获取资源相反，PUT 用于想服务器写入资源。PUT 的语义就是让服务器用请求的主体部分创建一个请求 URL 命名的文档，如果存在就替换 HEAD：获得报文首部HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。 DELETE：删除文件DELETE 方法按请求 URI 删除指定的资源，是与 PUT 相反的方法。 OPTIONS：询问支持的方法OPTIONS 方法用于请求 web 服务器告知其支持的各种功能 TRACE：追踪路径TRACE 方法是让 web 服务器端将之前的请求通信返回给客户端的方法。客户端发送一个请求的时候，这个请求可能会穿过防火墙、代理、网关和一些其它应用程序，没个中间节点都可能修改 HTTP 请求，TRACE 方法允许客户端在最终请求发往服务器的时候，看看它变成了什么样子TRACE 请求会在目的服务器端发送一个“闭环”诊断，行程最后一站服务器会弹回一条 TRACE 响应，并在响应主题中携带它收到的原始请求报文 CONNECT：要求用隧道协议连接代理CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。 状态码状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以指定服务器端是正常处理了请求，还是出现了错误。状态码如 200 OK ，以 3 位数字和原因短语组成。 状态码 类别 原因短语 1xx Informational(信息性状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端状态码) 服务器无法处理请求 5xx Server Error(服务器状态码) 服务器处理请求出错 1XX 100 Continue初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1 新） 101 Switching Protocols服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1 新） 2XX 成功响应的结果表明请求被正确的处理了。 200 OK表示客户端发来的请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发送改变。 201 Created服务器已经创建了文档，Location 头给出了它的 URL。 202 Accepted已经接受请求，但处理尚未完成。 203 Non-Authoritative Information文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1 新）。 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而 Servlet 可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1 新）。 206 Partial Content该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。客户发送了一个带有 Range 头的 GET 请求，服务器完成了它（HTTP 1.1 新）。 3XX 重定向浏览器需要执行某些特殊的处理以正确处理请求。 300 Multiple Choices客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在 Location 应答头指明。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。客户请求的文档在其他地方，新的 URL 在 Location 头中给出，浏览器应该自动地访问新的 URL。 302 Found临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户能使用新的 URI 访问。类似于 301，但新的 URL 应该被视为临时性的替代，而不是永久性的。注意，在 HTTP1.0 中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的 URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和 301 替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器 返回 301，有的则返回 302。严格地说，我们只能假定只有当原来的请求是 GET 时浏览器才会自动重定向。请参见 307。 303 See Other该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 光谷定向获取请求的资源。类似于 301/302，不同之处在于，如果原来的请求是 POST，Location 头指定的重定向目标文档应该通过 GET 提取（HTTP 1.1 新）。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304 Not Modified。304 状态码返回时，不包含任何响应的主体部分。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy客户请求的文档应该通过 Location 头所指明的代理服务器提取（HTTP 1.1 新）。 307 Temporary Redirect和 302 （Found）相同。许多浏览器会错误地响应 302 应答进行重定向，即使原来的请求是 POST，即使它实际上只能在 POST 请求的应答是 303 时才能重定 向。由于这个原因，HTTP 1.1 新增了 307，以便更加清除地区分几个状态代码：当出现 303 应答时，浏览器可以跟随重定向的 GET 和 POST 请求；如果是 307 应答，则浏览器只 能跟随对 GET 请求的重定向。（HTTP 1.1 新） 4XX 客户端错误4XX 响应结果表明客户端是发生错误的原因所在。 400 Bad Request请求出现语法错误。 401 Unauthorized发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。客户试图未经授权访问受密码保护的页面。应答中会包含一个 WWW-Authenticate 头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的 Authorization 头后再次发出请求。 403 Forbidden请求资源的访问被服务器拒绝了。资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404 Not Found服务器上无法找到请求的资源。 405 Method Not Allowed请求方法（GET、POST、HEAD、DELETE、PUT、TRACE 等）对指定的资源不适用。（HTTP 1.1 新） 406 Not Acceptable指定的资源已经找到，但它的 MIME 类型和客户在 Accpet 头中所指定的不兼容（HTTP 1.1 新）。 407 Proxy Authentication Required类似于 401，表示客户必须先经过代理服务器的授权。（HTTP 1.1 新） 408 Request Timeout在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1 新） 409 Conflict通常和 PUT 请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1 新） 410 Gone所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和 404 的不同在于，返回 407 表示文档永久地离开了指定的位置，而 404 表示由于未知的原因文档不可用。（HTTP 1.1 新） 411 Length Required服务器不能处理请求，除非客户发送一个 Content-Length 头。（HTTP 1.1 新） 412 Precondition Failed请求头中指定的一些前提条件失败（HTTP 1.1 新）。 413 Request Entity Too Large目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个 Retry-After 头（HTTP 1.1 新）。 414 Request URI Too LongURI 太长（HTTP 1.1 新）。 416 Requested Range Not Satisfiable服务器不能满足客户在请求中指定的 Range 头。（HTTP 1.1 新） 5XX 服务器错误5XX 的响应结果表明服务器本身发生错误。 500 Internal Server Error服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。 501 Not Implemented服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的 PUT 请求。 502 Bad Gateway服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 503 Service Unavailable服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。例如，Servlet 可能在数据库连接池已满的情况下返回 503。服务器返回 503 时可以提供一个 Retry-After 头。 504 Gateway Timeout由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1 新） 505 HTTP Version Not Supported服务器不支持请求中所指明的 HTTP 版本。（HTTP 1.1 新） 状态码 HTTPSWeb 的攻击技术]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变形与动画]]></title>
    <url>%2F2018%2F02%2F19%2F%E5%8F%98%E5%BD%A2%E4%B8%8E%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[transform()transform 属性允许你修改CSS视觉格式模型的坐标空间。使用它，元素可以被转换（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）。只对 block 级元素生效 rotate()旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。 123456789101112131415161718// HTML&lt;div class="wrapper"&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;// CSS.wrapper &#123; width: 200px; height: 200px; border: 1px dotted red; margin: 100px auto;&#125;.wrapper div &#123; width: 200px; height: 200px; background: orange; -webkit-transform: rotate(45deg); transform: rotate(45deg);&#125; skew()skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。123456transform: skew(ax[, ay]) /* one or two &lt;angle&gt;s, e.g. skew(30deg,-10deg) */// 元素在X轴和Y轴方向以指定的角度倾斜。如果ay未提供，在Y轴上没有倾斜。transform: skewX(angle) /* an &lt;angle&gt;, e.g. skewX(-30deg) */// 绕X轴以指定的角度倾斜transform: skewY(angle) /* an &lt;angle&gt;, e.g. skewY(4deg) */// 绕Y轴以指定的角度倾斜 scale()缩放 scale()函数 让元素根据中心原点对对象进行缩放。缩放 scale 具有三种情况： scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放） 123456div:hover &#123; -webkit-transform: scale(1.5,0.5); -moz-transform:scale(1.5,0.5) transform: scale(1.5,0.5);&#125;// Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。 scaleX(x)元素仅水平方向缩放（X轴缩放） scaleY(y)元素仅垂直方向缩放（Y轴缩放） translate()translate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。translate我们分为三种情况： translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）例:translate(100px,20px) translateX(x)仅水平方向移动（X轴移动） translateY(Y)仅垂直方向移动（Y轴移动） matrix()matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。a为元素的水平伸缩量，1为原始大小；b为纵向扭曲，0为不变；c为横向扭曲，0不变；d为垂直伸缩量，1为原始大小；e为水平偏移量，0是初始位置；f为垂直偏移量，0是初始位置matrix(scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY()); transform-origin任何一个元素都有一个中心点，默认情况之下，其中心点是居于元素X轴和Y轴的50%处。如下图所示：在没有重置transform-origin改变元素原点位置的情况下，CSS变形进行的旋转、位移、缩放，扭曲等操作都是以元素自己中心位置进行变形。但很多时候，我们可以通过transform-origin来对元素进行原点位置改变，使元素原点不在元素的中心位置，以达到需要的原点位置。transform-origin取值和元素设置背景中的background-position取值类似，如下表所示： transition在CSS中创建简单的过渡效果可以从以下几个步骤来实现：第一，在默认样式中声明元素的初始状态样式；第二，声明过渡元素最终状态样式，比如悬浮状态；第三，在默认样式中通过添加过渡函数，添加一些不同的样式。 CSS3的过度transition属性是一个复合属性，主要包括以下几个子属性： transition-property:指定过渡动画的CSS属性名称，而这个过渡属性只有具备一个中点值的属性（需要产生动画的属性）才能具备过渡效果 transition-duration:指定完成设置一个属性过渡到另一个属性所需的时间，也就是从旧属性过渡到新属性花费的时间长度过渡所需的时间 transition-timing-function:指定过渡函数,主要用来指定浏览器的过渡速度，以及过渡期间的操作进展情况，其中要包括以下几种函数： transition-delay:指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行。 有时我们想改变两个或者多个css属性的transition效果时，只要把几个transition的声明串在一起，用逗号（“，”）隔开，然后各自可以有各自不同的延续时间和其时间的速率变换方式。但需要值得注意的一点：第一个时间的值为 transition-duration，第二个为transition-delay。例如：a{ transition: background 0.8s ease-in 0.3,color 0.6s ease-out 0.3;}transition: property duration timing-function delay; animationanimation的子属性有: animation-delay设置延时，即从元素加载完成之后到动画序列开始执行的这段时间。 animation-direction设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。值：normal每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，这是默认属性。alternate动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向，比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭代reverse反向运行动画，每周期结束动画由尾到头运行。alternate-reverse反向交替， 反向开始交替动画第一次运行时是反向的，然后下一次是正向，后面依次循环。决定奇数次或偶数次的计数从1开始。 animation-duration设置动画一个周期的时长,也就是完成从0%到100%一次动画所需时间。 animation-iteration-count设置动画重复次数， 可以指定infinite无限次重复动画。其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。 animation-name指定由@keyframes描述的关键帧名称。 animation-play-state允许暂停和恢复动画。值:running当前动画正在运行。paused当前动画以被停止。 animation-timing-function设置动画速度， 即通过建立加速度曲线，设置动画在关键帧之间是如何变化。它和transition中transition-timing-function一样，具有以下几种变换方式：ease,ease-in,ease-in-out,ease-out,linear和cubic-bezier。 animation-fill-mode指定动画执行前后如何为目标元素应用样式。值：none动画执行前后不改变任何样式forwards目标保持动画最后一帧的样式，最后一帧是哪个取决于 animation-direction和 animation-iteration-count backwards动画采用相应第一帧的样式，保持 animation-delayboth动画将会执行 forwards 和 backwards 执行的动作。123456789&lt;!-- @keyframes duration | timing-function | delay | iteration-count | direction | fill-mode | play-state | name --&gt; animation: 3s ease-in 1s 2 reverse both paused slidein;&lt;!-- @keyframes duration | timing-function | delay | name --&gt; animation: 3s linear 1s slidein;&lt;!-- @keyframes duration | name --&gt; animation: 3s slidein; @keyframes123456789@keyframes &lt;identifier&gt; &#123; [ [ from | to | &lt;百分比&gt; ] [, from | to | &lt;百分比&gt; ]* block ]*&#125;&lt;!-- Values&lt;identifier&gt; 帧列表的名称。 名称必须符合 CSS 语法中对标识符的定义。from 等效于 0%.to 等效于 100%. --&gt; @keyframes让开发者通过指定动画中特定时间点必须展现的关键帧样式（或者说停留点）来控制CSS动画的中间环节。这让开发者能够控制动画中的更多细节而不是全部让浏览器自动处理。要使用关键帧, 先创建一个带名称的@keyframes规则，以便后续使用 animation-name这个属性来调用指定的@keyframes. 每个@keyframes 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。关键帧的编写顺序没有要求，最后只会根据百分比按由小到大的顺序触发。为了让一个关键帧列表有效，它必须至少包含了对0%（或from）和100%（或to）即动画的开头帧和结束帧的定义。 如果都没有进行定义，那么整个@keyframes 是无效的，不能使用。@keyframes 不能在内联样式中使用]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Media Queries]]></title>
    <url>%2F2018%2F02%2F18%2FMedia-Queries%2F</url>
    <content type="text"><![CDATA[Media QueriesMedia Queries使用方法1@media 媒体类型and （媒体特性）&#123;你的样式&#125; 注意：使用Media Queries必须要使用“@media”开头，然后指定媒体类型（也可以称为设备类型），随后是指定媒体特性（也可以称之为设备特性）。 媒体特性的书写方式和样式的书写方式非常相似，主要分为两个部分，第一个部分指的是媒体特性，第二部分为媒体特性所指定的值，而且这两个部分之间使用冒号分隔。例如：(max-width: 480px) 媒体特性 最大宽度“max-width”(max-width 表示最大即小于等于)是媒体特性中最常用的一个特性，其意思是指媒体类型小于或等于指定的宽度时，样式生效。如： 123456// 当屏幕小于或等于480px时,页面中的广告区块（.ads）都将被隐藏。@media screen and (max-width:480px)&#123; .ads &#123; display:none; &#125;&#125; 最小宽度“min-width”(min-width 表示最小即大于等于)与“max-width”相反，指的是媒体类型大于或等于指定宽度时，样式生效。 1234// 当屏幕大于或等于900px时，容器“.wrapper”的宽度为980px。@media screen and (min-width:900px)&#123; .wrapper&#123;width: 980px;&#125;&#125; 多个媒体特性使用关键词”and”将多个媒体特性结合在一起。也就是说，一个Media Query中可以包含0到多个表达式，表达式又可以包含0到多个关键字，以及一种媒体类型。 1234// 当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”@media screen and (min-width:600px) and (max-width:900px)&#123; body &#123;background-color:#f5f5f5;&#125;&#125; 在智能设备上，例如iPhone、iPad等，还可以根据屏幕设备的尺寸来设置相应的样式（或者调用相应的样式文件）。同样的，对于屏幕设备同样可以使用“min/max”对应参数，如“min-device-width”或者“max-device-width”。 12// “iphone.css”样式适用于最大设备宽度为480px&lt;link rel="stylesheet" media="screen and (max-device-width:480px)" href="iphone.css" /&gt; 使用关键词“not”是用来排除某种制定的媒体类型，也就是用来排除符合表达式的设备。换句话说，not关键词表示对后面的表达式执行取反操作，如： 12// 样式代码将被使用在除打印设备和设备宽度小于1200px下所有设备中。@media not print and (max-width: 1200px)&#123;样式代码&#125; only用来指定某种特定的媒体类型，可以用来排除不支持媒体查询的浏览器。其实only很多时候是用来对那些不支持Media Query但却支持Media Type的设备隐藏样式表的。其主要有：支持媒体特性的设备，正常调用样式，此时就当only不存在；表示不支持媒体特性但又支持媒体类型的设备，这样就会不读样式，因为其先会读取only而不是screen；另外不支持Media Queries的浏览器，不论是否支持only，样式都不会被采用。如: 1&lt;linkrel="stylesheet" media="only screen and (max-device-width:240px)" href="android240.css" /&gt; 在Media Query中如果没有明确指定Media Type，那么其默认为all，如：1&lt;linkrel="stylesheet" media="(min-width:701px) and (max-width:900px)" href="mediu.css" /&gt; 另外在样式中，还可以使用多条语句来将同一个样式应用于不同的媒体类型和媒体特性中，指定方式如下所示。12// style.css样式被用在宽度小于或等于480px的手持设备上，或者被用于屏幕宽度大于或等于960px的设备上。&lt;linkrel="stylesheet" type="text/css" href="style.css" media="handheld and (max-width:480px), screen and (min-width:960px)" /&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
